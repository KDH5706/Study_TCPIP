# Study_TCPIP
TCP/IP 학습 리포지토리

## 1일차
- 네트워크 프로그래밍 학습
- 소켓 통신에 관한 개념 학습
  - Linux 환경에서의 Server - Client 통신
  - 저 수준 파일 입출력과 파일 디스크립터 학습
  - Linux와 Window 간의 소켓 통신 학습
- TCP 통신과 UDP 통신의 차이 학습
- IP주소와 PORT번호 학습

## 2일차
- IPv4 기반의 주소표현을 위한 구조체 이해
  - sockaddr_in 구조체의 멤버에 대한 분석
- 바이트 순서와 네트워크 바이트 순서의 이해
  - 빅 엔디안 바이트 표현과 리틀 엔디안 바이트 표현 학습
  - 바이트 순서의 변환 학습
- 인터넷 주소의 초기화와 할당
  - inet_addr, inet_aton, inet_ntoa 함수의 이해
  - INADDR_ANY 상수를 통한 주소 정보 초기화 학습
- TCP 기반 서버, 클라이언트 구현
  - Iterative 에코 서버, 에코 클라이언트 구현
  - vmnetcfg 설정 및 VMWare 가상 머신을 통한 Linux 환경에서의 타 PC와의 TCP 통신
  
## 3일차
- TCP 기반 서버, 클라이언트 구현(응용)
  - 서버가 연산을 하여 결과를 리턴하는 계산기 시스템 구현
- TCP 통신 이론 학습
  - Three-way handshaking을 통한 상태 소켓과의 연결 이론 이해
  - ACK 메시지와 패킷의 SEQ를 통한 상대 소켓과의 데이터 송수신 이론 이해
  - Four-way handshaking을 통한 상대 소켓과의 연결 종료 이론 이해
- UDP 기반 서버, 클라이언트 구현
  - Iterative 에코 서버, 에코 클라이언트 구현
  - vmnetcfg 설정 및 VMWare 가상 머신을 통한 Linux 환경에서의 타 PC와의 UDP 통신
- UDP의 데이터 송수신 특성
  - 데이터의 경계(Datagram)가 존재하는 UDP 소켓의 송수신 프로세스 이해
  
## 4일차
- connected UDP 소켓의 개념 학습
- Half-close의 필요성에 대한 학습
  - shutdown(int sock, int howto) 함수 이해
  - Half-close 기반의 파일 전송 시스템 구현
- DNS 서버에 대한 학습
  - 도메인 이름으로 IP주소 얻기
  - IP주소로 도메인 정보 얻기
- 소켓 옵션과 입출력 버퍼의 크기 학습
  - SO_TYPE을 통해 TCP 소켓 및 UDP 소켓 타입 확인
  - SO_SNDBUF & SO_RCVBUF 크기 확인 및 설정
- 주소 할당 에러 발생에 대한 이론 이해
  - Time-wait 상태 및 주소의 재할당 학습
- Nagle 알고리즘 이론 이해

## 5일차
- 다중접속 서버의 구현 방법들 학습
  - 멀티프로세스 기반 서버 : 다수의 프로세스를 생성하는 방식
  - 멀티프렉싱 기반 서버 : 입출력 대상을 묶어서 관리하는 방식
  - 멀티쓰레딩 기반 서버 : 클라이언트의 수 만큼 쓰레드를 생성하는 방식
- fork 함수를 통한 프로세스 생성의 이해
- 좀비 프로세스의 생성 이유 학습
  - wait 함수를 이용한 좀비 프로세스 소멸
  - waitpid 함수를 이용한 좀비 프로세스 소멸
- 시그널 핸들링의 이해
  - signal 함수를 이용한 시그널 핸들링
  - sigaction 함수를 이용한 시그널 핸들링
- 시그널 핸들링을 통한 좀비 프로세스의 소멸
- fork 함수의 응용
  - fork 함수 호출을 통한 다중접속 에코 서버 구현
  - fork 함수 호출을 통한 입출력 루틴 분할 클라이언트 구현
- 프로세스간 통신(IPC)의 기본 이해
  - 파이프 기반의 프로세스간 통신 구현
 
## 6일차
- 멀티플렉싱의 개념 이해
  - select 함수의 이해와 서버 구현
  - fd_set형 변수의 핸들링에 필요한 매크로 함수의 이해
  - select 함수의 매개변수 및 리턴 값에 대한 이해(멀티플렉싱 기반 에코 서버 구현)
- Linux에서의 send & recv 함수의 이해
  - Out_of_band data 개념 이해
  - MSG_PEEK 옵션을 통한 입력 버퍼 검사
- readv & writev 입출력 함수의 이해
  - 여러 버퍼, 여러 저장소를 통해 나눠서 송수신하는 경우, 여러번의 write, read 보다는 writev, readv 함수를 호출하는 것이 효율적이다.
  - 성능 향상을 위해 Nagle 알고리즘을 중지시킨 경우(ex. 대용량 데이터의 전송) 더 큰 활용가치를 가지게 된다.
- 멀티캐스트와 브로드캐스트의 이해
  - 멀티캐스트 : 그룹에 가입만 되어 있으면 데이터 수신 가능
  - 브로드캐스트 : 동일한 네트워크로 연결되어 있는 호스트로 데이터 전송 대상이 제한됨
- 표준 입출력 함수의 이해
  - 파일 복사를 통한 표준 입출력 함수와 시스템 함수의 성능 비교
- 표준 입출력 함수 사용의 불편함
  - 양방향 통신이 쉽지 않다
  - 상황에 따라서 fflush 함수의 호출이 빈번
  - 파일 디스크립터를 FILE 구조체의 포인터로 변환 (fdopen)
- fdopen 함수와 fileno 함수의 이해
  - fdopen 함수를 이용한 FILE 구조체 포인터로의 변환
  - fileno 함수를 이용한 파일 디스크립터로의 변환
  
## 7일차
- 소켓 기반에서의 표준 입출력 함수 사용
  - sock 파일 디스크립터를 매개변수로하여 fdopen 함수를 통해 파일 구조체 포인터로의 변환
- 입출력 스트림의 분리에 대한 이해
  - 다중 프로세스에서의 fork 함수
  - 표준 입출력 함수에서의 fdopen 함수
- 파일 디스크립터의 복사와 Half-close
  - dup & dup2 함수를 통한 파일 디스크립터 복사
  - 파일 디스크립터의 복사 후 스트림의 분리
- epoll의 이해와 활용
  - epoll_create : epoll 파일 디스크립터 저장소 생성  
  - epoll_ctl	 : 저장소에 파일 디스크립터 등록 및 삭제
  - epoll_wait	 : select 함수와 마찬가지로 파일 디스크립터의 변화를 대기
- 레벨 트리거와 엣지 트리거
  - 레벨 트리거 : 입력버퍼에 데이터가 남아있는 동안에 계속해서 이벤트가 등록
  - 엣지 트리거 : 입력버퍼로 데이터가 수신된 상황에서 한번만 이벤트가 등록
